#! /usr/bin/env python3

import sys
import string
import argparse
import fileinput
import re
from collections import defaultdict

parser = argparse.ArgumentParser(description='A usefull summary of map files generated by gcc linker')
parser.add_argument("map_file", help="map file to process")
parser.add_argument("-d", "--debug", help="Print all processed mappings",
                    action="store_true")
parser.add_argument("-s", "--short", help="Print linker sections summary",
                    action="store_true")
parser.add_argument("-y", "--symbols", help="Print object symbols",
                    action="store_true")
parser.add_argument("-e", "--sections", help="Print object sections",
                    action="store_true")
parser.add_argument("-l", "--list", help="Print the list of objects name",
                    action="store_true")

args = parser.parse_args()

# The single mapping class, as found in the map file it corresponds to the single mapping
# of one object section to a linker section.
class SingleMap(object):
    def __init__(self, linker_sect, obj_map_sect, obj_map_size,
                 obj_name, obj_short_name, obj_sub_obj):
        self.linker_sect = linker_sect
        self.obj_map_sect = obj_map_sect
        self.obj_map_size = obj_map_size
        self.obj_name = obj_name
        self.obj_short_name = obj_short_name
        self.obj_sub_obj = obj_sub_obj #optional
        self.symbols = list()
    def print(self):
        print("------")
        print('full name      :  {}'.format(self.obj_name))
        print('short name     :  {}'.format(self.obj_short_name))
        print('sub obj        :  {}'.format(self.obj_sub_obj))
        print('obj section    :  {}'.format(self.obj_map_sect))
        print('size           :  {}'.format(self.obj_map_size))
        print('linker section :  {}'.format(self.linker_sect))
        for symbol in self.symbols:
            print(symbol)
    def add_symbol(self, symbol):
        self.symbols.append(symbol)

obj_name_dict = defaultdict(list)
linker_sect_dict = defaultdict(list)
linker_sect_sizes_dict = {}
cur_linker_sect = None
n_single_maps = 0

# Parse linker map
with fileinput.input(args.map_file) as f:
    for line in f:
        # Find new linker section
        m = re.match("(\.\S+)\s+0x[0-9a-f]+\s+(0x[0-9a-f]+)", line)
        if m:
            obj_sect = None
            cur_linker_sect = m.group(1)
            linker_sect_sizes_dict[cur_linker_sect] = int(m.group(2), base=16)
        else:
            if cur_linker_sect:
                # Find new object section
                m = re.match(" (\.\S+)", line)
                if m:
                    obj_sect = m.group(1)
                    new_map = True
                if obj_sect:
                    if new_map:
                        # group(1) size
                        # group(2) name
                        m = re.search("0x[0-9a-f]{16}\s+(0x[0-9a-f]+) (\S+)$", line)
                        if m:
                            # group(1) short name (archive, object)
                            # group(2) sub object (object in archive or None if not archive)
                            nm = re.search("\S+\/(\S+\.[a-z]+)(?:\((\S+)\))?$", m.group(2))
                            if (nm):
                                map_obj = SingleMap(cur_linker_sect,
                                                    obj_sect,
                                                    int(m.group(1), base=16),
                                                    m.group(2),
                                                    nm.group(1),
                                                    nm.group(2),)
                                new_map = False
                                n_single_maps += 1

                                # Store Single Map in convenient dictionaries
                                obj_name_dict[map_obj.obj_name].append(map_obj)
                                linker_sect_dict[map_obj.linker_sect].append(map_obj)

                                if args.debug:
                                    map_obj.print()
                    else:
                        m = re.match("\s+0x[0-9a-f]{16}\s+([0-9a-z_]+)$", line)
                        if m:
                            map_obj.add_symbol(m.group(1))

print('{} mappings processed'.format(n_single_maps))

if args.list:
    for name in sorted(obj_name_dict.keys()):
        map_obj = obj_name_dict[name][0]
        if map_obj.obj_sub_obj:
            name = "{}({})".format(map_obj.obj_short_name, map_obj.obj_sub_obj)
        else:
            name = map_obj.obj_short_name
        print(name)

    sys.exit(0)

print('Linker sections sizes')

# Print linker sections sizes
for section in linker_sect_sizes_dict.keys():

    print("{:16} : {:8d} Bytes ({:.2f} KBytes)".format(section,
                                                       linker_sect_sizes_dict[section] ,
                                                       linker_sect_sizes_dict[section] /1024))

if args.short:
    sys.exit(0)

# For all linker sections, add all mappings belonging to the same object
for section in linker_sect_dict.keys():
    if not linker_sect_sizes_dict[section]:
        continue

    print("{:56}: {:8d} Bytes".format(section, linker_sect_sizes_dict[section]))

    size_per_obj = {}
    sym_per_obj = defaultdict(list)
    sect_per_obj = defaultdict(set)

    # Go through all mappings that have been mapped to the linker section
    for map_obj in linker_sect_dict[section]:
        if map_obj.obj_sub_obj:
            name = "{}({})".format(map_obj.obj_short_name, map_obj.obj_sub_obj)
        else:
            name = map_obj.obj_short_name

        if name in size_per_obj:
            size_per_obj[name] += map_obj.obj_map_size
        else:
            size_per_obj[name] = map_obj.obj_map_size

        # Collect symbols
        sym_per_obj[name].extend(map_obj.symbols)

        # Collect sections
        sect_per_obj[name].add(map_obj.obj_map_sect)

        # Sort by size
        size_per_obj_sorted = sorted(size_per_obj.items(),
                                     key=lambda obj: obj[1],
                                     reverse=True)

    for obj in size_per_obj_sorted:
        print("        {:48}: {:8d} Bytes ({:.1f}%)".format(obj[0],
                                                            obj[1],
                                                            obj[1]*100/linker_sect_sizes_dict[section]))
        # Print sections of the object
        if args.sections:
            print("            sections:")
            for sect in sect_per_obj[obj[0]]:
                print("                    {:48}".format(sect))

        # Print symbols of the object
        if args.symbols:
            print("            symbols:")
            for sym in sym_per_obj[obj[0]]:
                print("                    {:48}".format(sym))


